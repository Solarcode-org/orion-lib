# Orion Grammar
auto-bump

lifetime 'lt

nonterminal E
nonterminal T : E

lexattribute set_line_comment("#")
lexterminal COMMA ,

terminals ( ) ; + - * / =
terminals let

resync ;

valueterminal IDENT~ &'lt str~ Alphanum(n) ~ n
valueterminal STRING~ &'lt str~ Strlit(n)~ &n[1..n.len()-1]
valueterminal INT~ i64~ Num(n)~ n
valueterminal FLOAT~ f64~ Float(n)~ n

topsym E

E:Let --> let IDENT = E
E:FuncCall --> IDENT ( E<COMMA*> )
E:Plus --> E + T
E:Minus --> E - T
E:Multiply --> E * T
E:Divide --> E / T
E:String --> STRING
E:Integer --> INT
E:Float --> FLOAT
E:Ident --> IDENT
E --> ( E )


$pub fn bumpz<'lt>(expr:&'lt E<'lt>, bump:&'lt bumpalo::Bump) -> &'lt E<'lt> {
$ use E::*;
$ let REF = |x|{bump.alloc(x)}; // for simplified syntax
$ let bumper = |x|{bumpz(x,bump)};
$ match expr {
$  Plus(a,b) => REF(Plus(bumper(a),bumper(b))),
$  Minus(a,b) => REF(Minus(bumper(a),bumper(b))),
$  Multiply(a,b) => REF(Multiply(bumper(a),bumper(b))),
$  Let(varname,value) => REF(Let(varname,bumper(value))),
$  FuncCall(func,args) => REF(FuncCall(func,args.to_vec())),
$  Divide(a,b) => REF(Divide(bumper(a),bumper(b))),
$  expr => expr, //default no change to literals
$ }//match
$}

$#[derive(Clone)]
