//Parser generated by rustlr for grammar orion
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(unreachable_patterns)]
#![allow(irrefutable_let_patterns)]
use std::rc::Rc;
use std::cell::RefCell;
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use rustlr::{LC,Bumper};
use crate::orion_ast::*;

static SYMBOLS:[&'static str;21] = ["_WILDCARD_TOKEN_","E","T","COMMA","(",")",";","+","-","*","/","=","let","IDENT","STRING","INT","FLOAT","NEWSEPNT_2_0","NEWSEPNT2_4_1","START","EOF"];

static TABLE:[u64;320] = [64424574976,17180262400,4295163905,60129869824,68719935488,55834705920,51539869696,281509337169922,281560876777474,281517927104514,281513632137218,281505042202626,562988608978946,562980019044354,562967133814784,562992903946242,562984314011650,563035853619202,844510829477891,844459290656768,844467880525824,844463585492992,844454995492864,1125955742269440,1407413538914306,1407460783554562,1407409243947010,1407404948979714,1407417833881602,1688918580723712,1688914286084096,1688909991051264,1688854156279809,1688901400985600,1688905695756288,1688867041312768,1970363492466690,1970354902532098,1970367787433986,1970359197499394,1970410737106946,2251868534734848,2251855649964032,2251864239702016,2251859944865792,2251872830029825,2251816995323904,2251877124931585,2251851354669056,2251804110094337,2251821288783874,2533283382296577,2814758359072769,3096233335848961,3377708312625153,3659221944107008,3940688329506818,3940679739572226,3940671149637634,3940666856112128,3940684034539522,3940692624474114,4222154716217346,4222146126282754,4222163306151938,4222159011184642,4222167601119234,4503629694763008,4503642579402752,4503621104762880,4503638284566528,4503633989533696,4785130441342976,5066614006611968,5066601121513472,5066566761840640,5066605416284160,5066618301251584,5066609711579136,5066553878511617,5348046032994306,5348054622928898,5348067507830786,5348058917896194,5348063212863490,5629521009770498,5629542484606978,5629533894672386,5629529599705090,5629538189639682,5911030348316672,6192488145420288,6192462372667394,6192483850256384,6192492440322048,6192479555354624,6192470962601986,6473945939902466,6473967414738946,6473937349967874,6473963119771650,6473954529837058,6473958824804354,6755433801580546,6755438096547842,6755412326744066,6755442391515138,6755420916678658,6755429506613250,7036895893258242,7036904483192834,7036908778160130,7036917368094722,7036887303323650,7036913073127426,7318392345001986,7318366577491968,7318379460100098,7318370870165506,7318383755067394,7318388050034690,7318362280230914,7599841552236544,7599828669366273,7599875911909376,7599884501975040,7599893091647488,7599880206680064,7599888797007872,7881320826011648,8162795799773186,8162787212853248,8444292251385858,8444287956418562,8444279366483970,8444283661451266,8444335201058818,8725754343325698,8725767228227586,8725758638292994,8725762933260290,8725810177900546,9007285154676738,9007237910036482,9007233615069186,9007242205003778,9007229320101890,9288704296681474,9288717181583362,9288712886616066,9288760131256322,9288708591648770,9570205042868224,9570153506537473,9570209338032128,9570213632737280,9570166388424704,9570200748032000,9570217928097792,9851692905922560,9851628481282049,9851680021151744,9851684316053504,9851645659971586,9851701497757697,9851641366511616,9851688610889728,9851675725856768,9851697201217537,10133107755057153,10414582731833345,10696057708609537,10977609991979010,10977562747338754,10977554157404162,10977567042306050,10977558452371458,11259007662096385,11540521293578240,11821979089240064,11821983384010752,11821970500550656,11821991973879808,11821987679043584,12103471247130624,12384907569201153,12666382545977345,12947857522753537,13229332499529729,13510816063750144,13510859013292032,13510863308128256,13510803178520577,13510820357210114,13510871898456065,13510854718390272,13510867603161088,13510850423095296,13510876195782657,13792295337984000,13792316810854400,13792303926214656,13792312516018176,13792308220985344,14073834734944258,14073791785271298,14073778900369410,14073787490304002,14073783195336706,14355275353227264,14355288238260224,14355292533293056,14355228111601665,14355240993882112,14355283943424000,14355279648522240,14636784688300034,14636728854315008,14636737444315136,14636741739347968,14636733149478912,14918195244957696,15199670217801730,15199687397670914,15199678807736322,15199683102703618,15199691692638210,15481162374250498,15481158079283202,15481145194381314,15481153784315906,15481166669217794,15762628761092098,15762641645993986,15762620171157506,15762633056059394,15762637351026690,16044116622573570,16044108032638978,16044095147737090,16044112327606274,16044103737671682,16325613075038208,16325552948707329,16325617369677824,16325600189939712,16325604484710400,16325565830266880,16325608780005376,16607066576519170,16607045101682690,16607057986584578,16607062281551874,16607053691617282,16888550143623168,16888515784278016,16888502902194177,16888563028656128,16888567323688960,16888554438918144,16888558733819904,17170016529481730,17170012234514434,17170003644579842,17169995054645250,17169986464710658,17170007939547138,17451482916192258,17451461441355778,17451487211159554,17451478621224962,17451470031290370,17451491506126850,17732936418263042,17732962188066818,17732953598132226,17732966483034114,17732945008197634,17732957893099522,18014428574777346,18014437164711938,18014441459679234,18014411394908162,18014432869744642,18014419984842754,18295894965682176,18577382823559170,18577378528591874,18577369938657282,18577391413493762,18577387118526466,18577361348722690,18858862097399808,18858836324712450,18858853507334144,18858844914647042,18858866392301568,18858857802235904,19140328481161218,19140341366063106,19140337071095810,19140332776128514,19140319891226626,19421794867871746,19421807755198464,19421803460427776,19421816345067520,19421812050231296,19703269844582402,19703287027531776,19703278437466112,19703282732367872,19703291322433536,19703261254647810,19984757706260482,19984762001227778,19984766296195074,19984753411293186,19984736231424002,19984744821358594,];


fn _semaction_rule_0_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item3_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E<'lt>>::default()}; let mut _item2_ = if let RetTypeEnum::Enumvariant_14(_x_14)=parser.popstack().value { _x_14 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_7(_x_7)=parser.popstack().value { _x_7 } else {<&'lt str>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_14(_x_14)=parser.popstack().value { _x_14 } else {<()>::default()};  E::Let(_item1_,parser.exstate.make(_item3_)) }

fn _semaction_rule_1_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item3_ = if let RetTypeEnum::Enumvariant_14(_x_14)=parser.popstack().value { _x_14 } else {<()>::default()}; let mut _item2_ = if let RetTypeEnum::Enumvariant_11(_x_11)=parser.popstack().value { _x_11 } else {<Vec<&'lt LC<E<'lt>>>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_14(_x_14)=parser.popstack().value { _x_14 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_7(_x_7)=parser.popstack().value { _x_7 } else {<&'lt str>::default()};  E::FuncCall(_item0_,_item2_) }

fn _semaction_rule_2_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Vec<&'lt LC<E<'lt>>> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E<'lt>>::default()};  vec![parser.exstate.make(parser.lc(0,_item0_))] }

fn _semaction_rule_3_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Vec<&'lt LC<E<'lt>>> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_14(_x_14)=parser.popstack().value { _x_14 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_11(_x_11)=parser.popstack().value { _x_11 } else {<Vec<&'lt LC<E<'lt>>>>::default()};  _item0_.push(parser.exstate.make(parser.lc(2,_item2_))); _item0_ }

fn _semaction_rule_4_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Vec<&'lt LC<E<'lt>>> {
 vec![] }

fn _semaction_rule_5_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Vec<&'lt LC<E<'lt>>> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_11(_x_11)=parser.popstack().value { _x_11 } else {<Vec<&'lt LC<E<'lt>>>>::default()}; _item0_ }

fn _semaction_rule_6_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_14(_x_14)=parser.popstack().value { _x_14 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E<'lt>>::default()};  E::Plus(parser.exstate.make(_item0_),parser.exstate.make(_item2_)) }

fn _semaction_rule_7_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_14(_x_14)=parser.popstack().value { _x_14 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E<'lt>>::default()};  E::Minus(parser.exstate.make(_item0_),parser.exstate.make(_item2_)) }

fn _semaction_rule_8_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_14(_x_14)=parser.popstack().value { _x_14 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E<'lt>>::default()};  E::Multiply(parser.exstate.make(_item0_),parser.exstate.make(_item2_)) }

fn _semaction_rule_9_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_14(_x_14)=parser.popstack().value { _x_14 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E<'lt>>::default()};  E::Divide(parser.exstate.make(_item0_),parser.exstate.make(_item2_)) }

fn _semaction_rule_10_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_7(_x_7)=parser.popstack().value { _x_7 } else {<&'lt str>::default()};  E::String(_item0_) }

fn _semaction_rule_11_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_5(_x_5)=parser.popstack().value { _x_5 } else {<i64>::default()};  E::Integer(_item0_) }

fn _semaction_rule_12_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_6(_x_6)=parser.popstack().value { _x_6 } else {<f64>::default()};  E::Float(_item0_) }

fn _semaction_rule_13_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_7(_x_7)=parser.popstack().value { _x_7 } else {<&'lt str>::default()};  E::Ident(_item0_) }

fn _semaction_rule_14_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_14(_x_14)=parser.popstack().value { _x_14 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_14(_x_14)=parser.popstack().value { _x_14 } else {<()>::default()};  _item1_ }

fn _semaction_rule_15_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> () {
let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E<'lt>>::default()}; <()>::default()}

pub fn make_parser<'lt>() -> ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>
{
 let mut parser1:ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>> = ZCParser::new(16,72);
 let mut rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("start");
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_0_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_1_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("NEWSEPNT_2_0");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_11(_semaction_rule_2_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("NEWSEPNT_2_0");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_11(_semaction_rule_3_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("NEWSEPNT2_4_1");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_11(_semaction_rule_4_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("NEWSEPNT2_4_1");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_11(_semaction_rule_5_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_6_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_7_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_8_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_9_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_10_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_11_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_12_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_13_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_14_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("START");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_14(_semaction_rule_15_(parser)) };
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..320 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

pub fn parse_with<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>, lexer:&mut orionlexer<'lt>) -> Result<E<'lt>,E<'lt>>
{
  if lexer.bump.is_some() {parser.exstate.set(lexer.bump.unwrap());}
  lexer.shared_state = Rc::clone(&parser.shared_state);
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse(lexer) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<E<'lt>>::default())}
}//parse_with public function

pub fn parse_train_with<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>, lexer:&mut orionlexer<'lt>, parserpath:&str) -> Result<E<'lt>,E<'lt>>
{
  if lexer.bump.is_some() {parser.exstate.set(lexer.bump.unwrap());}
  lexer.shared_state = Rc::clone(&parser.shared_state);
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse_train(lexer,parserpath) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<E<'lt>>::default())}
}//parse_train_with public function

//Enum for return values 
pub enum RetTypeEnum<'lt> {
  Enumvariant_2((usize,usize)),
  Enumvariant_7(&'lt str),
  Enumvariant_6(f64),
  Enumvariant_11(Vec<&'lt LC<E<'lt>>>),
  Enumvariant_0(E<'lt>),
  Enumvariant_5(i64),
  Enumvariant_14(()),
}
impl<'lt> Default for RetTypeEnum<'lt> { fn default()->Self {RetTypeEnum::Enumvariant_0(<E<'lt>>::default())} }


// Lexical Scanner using RawToken and StrTokenizer
pub struct orionlexer<'lt> {
   stk: StrTokenizer<'lt>,
   keywords: HashSet<&'static str>,
   lexnames: HashMap<&'static str,&'static str>,
   shared_state: Rc<RefCell<Bumper<'lt,()>>>,
   bump: Option<&'lt bumpalo::Bump>,
}
impl<'lt> orionlexer<'lt> 
{
  pub fn from_str(s:&'lt str) -> orionlexer<'lt>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'lt LexSource<'lt>) -> orionlexer<'lt>  {
    let mut st = Self::new(StrTokenizer::from_source(s));
    st.bump = s.get_bump();
    st
  }
  pub fn new(mut stk:StrTokenizer<'lt>) -> orionlexer<'lt> {
    let mut lexnames = HashMap::with_capacity(64);
    let mut keywords = HashSet::with_capacity(64);
    let shared_state = Rc::new(RefCell::new(<Bumper<'lt,()>>::default()));
    for kw in ["_WILDCARD_TOKEN_","let",] {keywords.insert(kw);}
    for c in ['(',')',';','+','-','*','/','=',',',] {stk.add_single(c);}
    for d in [] {stk.add_double(d);}
    for d in [] {stk.add_triple(d);}
    for (k,v) in [(r#","#,"COMMA"),] {lexnames.insert(k,v);}
    stk.set_line_comment("#");
    let bump:Option<&'lt bumpalo::Bump> = None;
    orionlexer {stk,keywords,lexnames,shared_state,bump,}
  }
}
impl<'lt> Tokenizer<'lt,RetTypeEnum<'lt>> for orionlexer<'lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'lt,RetTypeEnum<'lt>>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => {
        let truesym = self.lexnames.get(sym).unwrap_or(&sym);
        Some(TerminalToken::from_raw(token,truesym,<RetTypeEnum<'lt>>::default()))
      },
      RawToken:: Alphanum(n)  => Some(TerminalToken::from_raw(token,"IDENT",RetTypeEnum::Enumvariant_7( n
))),
      RawToken:: Strlit(n) => Some(TerminalToken::from_raw(token,"STRING",RetTypeEnum::Enumvariant_7( &n[1..n.len()-1]
))),
      RawToken:: Num(n) => Some(TerminalToken::from_raw(token,"INT",RetTypeEnum::Enumvariant_5( n
))),
      RawToken:: Float(n) => Some(TerminalToken::from_raw(token,"FLOAT",RetTypeEnum::Enumvariant_6( n
))),
      RawToken::Symbol(s) if self.lexnames.contains_key(s) => {
        let tname = self.lexnames.get(s).unwrap();
        Some(TerminalToken::from_raw(token,tname,<RetTypeEnum<'lt>>::default()))
      },
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'lt>>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'lt>>::default())),
      _ => { let _rrodb=token.0.to_staticstr(); Some(TerminalToken::from_raw(token,_rrodb,<RetTypeEnum<'lt>>::default())) },
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
   fn current_line(&self) -> &str {self.stk.current_line()}
   fn get_line(&self,i:usize) -> Option<&str> {self.stk.get_line(i)}
   fn get_slice(&self,s:usize,l:usize) -> &str {self.stk.get_slice(s,l)}
   fn transform_wildcard(&self,t:TerminalToken<'lt,RetTypeEnum<'lt>>) -> TerminalToken<'lt,RetTypeEnum<'lt>> { TerminalToken::new(t.sym,RetTypeEnum::Enumvariant_7(self.stk.current_text()),t.line,t.column) }
}//impl Tokenizer

fn load_extras<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>)
{
}//end of load_extras: don't change this line as it affects augmentation
