//Bump-allocated AST types generated by rustlr for grammar orion
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_imports)]
#![allow(dead_code)]
use rustlr::{LC,Bumper};

pub fn bumpz<'lt>(expr:&'lt E<'lt>, bump:&'lt bumpalo::Bump) -> &'lt E<'lt> {
 use E::*;
 let REF = |x|{bump.alloc(x)}; // for simplified syntax
 let bumper = |x|{bumpz(x,bump)};
 match expr {
  Plus(a,b) => REF(Plus(bumper(a),bumper(b))),
  Minus(a,b) => REF(Minus(bumper(a),bumper(b))),
  Multiply(a,b) => REF(Multiply(bumper(a),bumper(b))),
  Let(varname,value) => REF(Let(varname,bumper(value))),
  FuncCall(func,args) => REF(FuncCall(func,args.to_vec())),
  Divide(a,b) => REF(Divide(bumper(a),bumper(b))),
  expr => expr, //default no change to literals
 }//match
}
#[derive(Clone)]


#[derive(Debug)]
pub enum E<'lt> {
  String(&'lt str),
  FuncCall(&'lt str,Vec<&'lt LC<E<'lt>>>),
  Float(f64),
  Minus(&'lt E<'lt>,&'lt E<'lt>),
  Plus(&'lt E<'lt>,&'lt E<'lt>),
  Ident(&'lt str),
  Integer(i64),
  Divide(&'lt E<'lt>,&'lt E<'lt>),
  Let(&'lt str,&'lt E<'lt>),
  Multiply(&'lt E<'lt>,&'lt E<'lt>),
  E_Nothing,
}
impl<'lt> Default for E<'lt> { fn default()->Self { E::E_Nothing } }

